			    Spring Boot
.....................................................................................

What is Spring Boot?
What is difference Between Spring boot and Spring framework(old spring)-Spring core?
How to build distributed java applications using spring
 -Microservices.
.....................................................................................
			   Spring Framework && Spring Boot
.....................................................................................

What is Spring Framework?

  Spring is Java Framework to build enterprise distributed application.

Types of application?

=>Desktop application

=>Network based application
   Apps runs in the remote machine and accessed that apps via network.
 =>Client Server Arch
	Application has three major layer(tier)
    ->Data Layer -Where we store data
    ->Biz layer - Where we process data
    ->Presentation Layer - Where we present  data

->Mainframe based arch : The first network based application
->Layered Client server arch without mainframeworks

    ->Single/One tier client server - >Both storage and biz processing kept in single 				      machine,where as ui layer is kept separately.

  ->Two/tier client server
        Database/Storage layer is separated, biz processing layer is kept in one 	      machine, and ui also kept in the same machine.

 ->Three tier client server 
	Data layer , Biz processing layer, Ui layer is kept in different machines

->N-tier client server 
      Data Layer
      Biz processing layer
	->MOM Layer - Message oriented middlware -
        ->Rpc layer - Remote Procedure call-app to app interaction.
        ->Integration layer - ESB (Enterprise Server Bus)
    Each layer can be kept in different and different machines , each layer can communicate over network using its own networking protocals

What is Distributed Application?
    Distributed application is other wise called "N-tier client server arch"
 Software components runs in different and different machines and talks over networking using "its own protocal"..

How to build distributed apps?
   You can build distributed applications in any technology like "java",".netnet",php,python,node.js,.....

Distributed application types:
..............................
Now a days distributed apps are built using various patterns.

1.Monolithic Architecture pattern
    Legacy way of building "distributed apps"
2.Microservice Architecture pattern
    Modern way of building "distributed apps"

	  Since Spring is Distribtued java App framework
	   We can build "Mononlolithic" and also we can 
	    build "Microservices" based apps.

			Spring
			  |
	  ------------------------------------------------
          |                                              |
    Monolothic                                     Microserivces



As a java developer, I need to know what are the concepts available to start 
building Monololithic apps in Spring.

1.Spring core Framework & Boot
2.Spring Data 
3.Api Development using webservices - Rest / Soap
4.Integration /MOM using Rabbitmq or Kafka....


As a java developer, I need to know what are the concepts available to start 
building Microservices apps in Spring.


1.Spring core Framework & Boot
2.Spring Data 
3.Api Development using webservices - Rest / Soap
4.Integration /MOM using Rabbitmq or Kafka....
5."Spring Cloud"- framework which provides all infrastructure
  to build Microservices based distributed apps.
....................................................................................
....................................................................................
			 History Of Spring Framework
....................................................................................

Early 2000,Java become very popular for building distributed Applications.

Java Technology Types:

1.JSE 
   -Core java programming language
2.JEE
  -Building distributed apps 
3.JME
  -Device apps like mobile

JCP - Java Community Process
 Who standarize the entire Java Technology.

Java works based on Specification,
   Rules and regualations how things are working.

JSE - How java programming language works
JVM - How Java vm can be implementated.

....................................................................................
                             JEE -Enterprise Specification
.....................................................................................

JEE Platform spec : containers /app containers/tools

1.Web Technology spec
 Java servlet
 JSP
 JSF
 Websocket
 JSTL
 EL
2.Enterprise Application spec
EJB
JPA -ORM
JMS
JTA
DI
Context and DI
Concurrency Util

3.Web Services

SOAP based  -JAX-WS
REST Based  -JAX-RS

4.Management and Security technologies
........................................
Java EE Security spec
Java Auth
Java authorzation
JAVA EE additional spec
JMX -Jmeter

...................................................................................
		Complixty of JEE Spec and implementation
.....................................................................................

JEE enterprise/distributed application:
......................................

Client Layer         Web Layer      Biz layer      Data Layer/Persistency

Browser             Servlet/JSP      EJB               EJB - Entity Beans


EJB :Enterprise Java Bean
  Java Object can support distributed biz operations
eg: incase of shopping cart
  I have a bean(java object) which has three apis addToCart,Checkout,Payment

Api classifications:
1.Session Bean  - to represent biz logic---jdbc--dml
2.Enitity bean  -ORM - Object to Table mapping-First orm solution---Hibernate
3.Message Driven Bean - Message driven systems-RabbitMQ,JMS


Rod johnson  was working in enterprise banking application with jee, he faced lot of 
complexity in designing ejb driven systems, so he decided to move out ejb from JEE application, he wrote book called expert  J2EE ONE ON ONE design and development.

He proposed a model  that model later on came as The project in "Spring Season" - Spring Framework.

Client Layer         Web Layer      Biz layer                Data Layer/Persistency

Browser             Spring MVC     Spring Services          Spring-orm - Spring-								    data

Spring development objective is "POJO". (Plain Old Java Object)

When you build enterprise java apps, no plumbing(bolier plate code),Spring framework takes care that plumbing.


Java is Object Oriented Programming language.

Apps built on java collection of objects.

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency

1.Object Management :Hierarchy

Object Relationship

-HAS-A -  Composition
-IS-A - Inheritance.

Enterprise application challanges:

1.Object Management

class Order {
   Product product
}

class Customer{
   Order order
}

class Product {
  Item item
}
class Item {

}

Customer information
 ->Order
     -Product
        -Item

You have to create Object for every class
You have to pass object reference to every Object - HAS-A

new Customer(new Order(new Item()))


IOC : Inversion of Control
 Inversion -Do opposit
 of Control -Management

In enterprise application object creation and linking objects are so complex that should be removed from the developer.

Someone should take care object creation and linking= 
  =>This process is called as IOC.
The IOC suggest the automation program,that program called as IOC Container.

Management - creating object and mainitain its relationship references
		-developer via code

Do Opposit - Dont create object , dont management object life cycle
   IOC
Some body has to create objects and manage its relationship - "Automated Program"
   -IOC Container

ioc container implementation:
 -Spring framework provides at core ioc container - Spring Context

....................................................................................
.....................................................................................
			Spring Application
.....................................................................................
   The application is written in java technology, executed on Spring Container which is runtime for spring applications.spring container runs on jvm


			  Spring Application
				 |
			   Spring Container
				 |
				JVM


What is framework?
   One Stop Solution
 Collection of tools and technologies provided in one place to build end to end applications mostly.
  
  
What spring framework offers?

 Spring offers collection of many projects.


1.Core:

IoC container,
Events, 
Resources, 
i18n,
Validation,
Data Binding,
Type Conversion, 
SpEL,
AOP.

2.Spring MVC
3.Spring cloud
etc....
https://spring.io/projects/
....................................................................................
				Spring Core principle
.....................................................................................

Make Java enterprise distributed application easy way.

=>IOC and Dependency Injection
     -How to create objects and how to link objects.



Spring Provides

1.Application code
   classes which expose biz logic and apis - written by developer

2.Infrastructure code - provided by framework
  creating objects
  initalization dependencies

Spring takes care of infra code, where developer takes care of app code.

Object Creation In spring:
.........................
 In Spring Object creation and linking objects must be separated from the developer
 	-IOC and DI

For implementing IOC and DI, spring offers three technique

Spring is based on Configurtion:

Three types of configuration:

1.XML driven - old way of configuration
2.Java Config Driven - after xml
3.Boot Driven - highly automated configuration system.

We are going to see all types of configuration...


.....................................................................................
				   Tools For Spring Application Development
....................................................................................
1.JDK   17 | 21
   HotSpot or OpenJDk
2.Build Tools
   Maven,Gradle
3.Docker

Spring Versions and features

2004 - Spring Framework 1.0 released
– Champions dependency injection
– Encourages POJOs
– Uses XML files to describe application
  configuration
– Becomes popular quickly as an EJB
  alternative

• Spring 2.0 (2006):
 – XML simplification, async JMS, JPA, AspectJ support

• Spring 2.5 (2007, last release 2.5.6)
  – Requires Java 1.4+ and supports JUnit 4
  – Annotation DI, @MVC controllers, XML namespaces

• Spring 3.x (3.2.17 released July 2013)

   – Environment & Profiles, @Cacheable, @EnableXXX …
   – Requires Java 1.5+ and JUnit 4.7+
   – REST support, JavaConfig, SpEL, more annotations

• Spring 4.x (released Dec 2016)
    – Support for Java 8, @Conditional, Web-sockets

• Spring 5.x (2017) - Spring Boot
  MicroService driven Dev features
   – Reactive programming focus
   - Functional Programming
   - Cloud Functionality
   - Container support

• Spring 6.x (2023)
   -Java 11 and 17 LTS support
   -Only improvments and bug fixing

Spring Boot:
  Spring was available inside Spring Framework 5.x 
  later it became independant project
  Now days only Spring boot is defacto standard for configuring spring applications
  
  Spring boot 3.1 is new Spring Boot Release


				Spring Core Concepts
....................................................................................

Spring Core Concepts:

1.Spring Bean

What is Bean?
   
  Bean is terminallogy coined by SUN Micro System to name java object.


Object vs Bean?

 -Same but Bean has some special characteristics  which was proposed by SUN micro system via "Java Bean Spec"

It is java class, based Java Bean standards
 	-class should be public
 	-properties should be private
 	-set and get methods - Accessors and mutators
	-constructors


Why Bean Spec?
  - in order to standarize the java dev process- Coding Standards.

public class Customer {
  private  int id;
  private String name;
}
    "Spring  follows java bean spec in order to create object and links objects"

class CustomerService {

   private CustomerRespository rep;

   CustomerService(){

   }
   set /get

}
class CustomerRespository{


}

Spring Bean is Java Object follows Bean Specification and also managed by Spring Container.

....................................................................................			  	 Spring Bean Creation(Object)
.....................................................................................


Who creates Spring Beans?

 -Spring Container

 Spring container is java object, which manages object(bean) life cycle like   create,use,destroy.

How spring beans are created?

-> you must have bean definitions outside application biz logic
-> sp container reads that bean definitions, initalizes the beans.

Architecture:

			POJO Classes(Bean)
				 |
    Spring-Application <====>SpringContainer
      config file		 |
		       Fullyconfigured System


Spring Bean Definitions(file) instructs Spring Container how to create objects(order of creations) and how to link (DI) objects

....................................................................................
			Spring Application Configuration Management
.....................................................................................
Spring Application can be configured in many ways

1.XML files  -  Old and Legacy.

2.Java Config + Annotations -Modern way

2.1 Java Config -Manual - Write Configuration and logic

 Here Dev need to write Configuration and biz logic , which makes app dev slower.

Just Focus logic, automate configuration itself - AutoConfig

3.AutoConfig:
    Framework must take care of configuration based on various conditions like
 i want web and jpa , messaging.
                        "Birth of Spring Boot"

....................................................................................
....................................................................................
				Spring Project Setup 
	    

What are the required components to setup Spring Project.

1.IDE,mvn,java

2.Project layout

Spring Project requires

Infra Structure:
 1.Project libraries

 2.Project Configurations

Application Structure

1.Application code
2.assets - imgs,docs
3.App Configuration

mvn or gradle

..............................

.............................................................................................
				    Spring Project Creations
............................................................................................

Whether you build app using Boot or Old Spring Framework Two things you have to take care

1.Project Dependency -  Libraries- core,web,data,cloud,logger....
  You have to manage
  Spring have to manage - Boot via starters

2.Application Configuration
   -Bean defintions -  xml, or javaconfig- manual/auto(spring boot)
   
Spring Project Using Spring Framework method:
.............................................

XML based project:
.................


Steps:

1.create Plain Maven Project and spring dependency.

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>SpringCoreApp</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>6.1.5</version>
        </dependency>
    </dependencies>

</project>
.....................................................................................
			 Object creations without spring
.....................................................................................

Declare Bean:
package com.ibm.spring.core.beans;

public class Customer {
    private int id;
    private String name;

    public Customer() {
    }

    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

Declare Main class and Create Object;
.....................................

package com.ibm.spring.core.beans;

public class ObjectCreationWithoutSpring {
    public static void main(String[] args) {
        //create object
        Customer customer = new Customer();
        //populate data : via setters
        customer.setId(1);
        customer.setName("Subramanian Murugan");

        //read Data : via getters
        System.out.println(customer.getId() + " " + customer.getName());

        //via constructor how to initialize object
        customer = new Customer(2, "Murugan");
        System.out.println(customer.getId() + " " + customer.getName());

    }
}


here 
=> we create objects
=> we popuplate data via setters and constructors.
....................................................................................
			Object creations via Spring Frameworks
...................................................................................
In order to create object by spring, we need a configuration system.

1.XML based configuration- very very old-nobody is using today, but which is foundation for modern spring configuration(auto-spring boot)

2.java config - new way of configuration used today- auto config.


XML based configuration:
1.config xml

place beans.xml in the class path - resources/beans.xml


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
    <bean id="customer" class="com.ibm.spring.core.beans.Customer">
        <!--        Default values set via setters-->
        <!--        <property name="id" value="1"/>-->
        <!--        <property name="name" value="Ram"/>-->

        <!--        Default values set via constructors-->
        <constructor-arg name="id" value="0"/>
        <constructor-arg name="name" value="Foo"/>

    </bean>
</beans>

package com.ibm.spring.core.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ObjectCreationsWithSpring {
    public static void main(String[] args) {
        //initialize the spring container and gets the bean from spring container
        //Load Spring Container:XMLContainer,JavaConfigContainer,BootContainer
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        Customer customer = context.getBean(Customer.class);
        System.out.println(customer.getId() + customer.getName());

        customer.setName("Subramaniam");
        customer.setId(1);

        System.out.println(customer.getId() + customer.getName());

        customer.setId(3);
        customer.setName("Ram");
        System.out.println(customer.getId() + customer.getName());


    }
}
...................................................................................
			 Depedency Injection


What is dependency Injection?

  Creating Objects
  Linking objects
  Setting Object Property values
  Setting Object references with Object who refers it.

Dependency Injection on reference types and Primitives.

class Customer {
   private int id - primtive - Dependency
   private Order order - Reference type - Dependency
}

Types of DI:

1.Setter
    Linking objects after objects created
2.Constructor
    Linking objects, During object creation.
3.Field Injection
   Linking objects after Creation



When to use Setter vs Constructor?

Note: 
 Constructor properties are initlized during object creations
 Settter properties are initlized after object creations

Spring supports both.You can mix and match.


Constructors:
  ->Enforce mandatory dependencies

Setters:
 1.Allow optional dependenices


Setter and constructor injections can be done with primtive data types and reference types:


Reference Type eg:
..................

Customer has address.

Setter Example:

beans-di.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="custAddress" class="com.ibm.spring.core.di.Address">
        <property name="city" value="City"/>
        <property name="state" value="State"/>
    </bean>
    <bean id="customer" class="com.ibm.spring.core.di.Customer">
        <property name="id" value="0"/>
        <property name="name" value="Name"/>
        <!--        Dependency Injection-->
        <property name="address" ref="custAddress"/>
    </bean>

</beans>


package com.ibm.spring.core.di;

public class Address {
    private String city;
    private String state;

    public Address() {
    }

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}


package com.ibm.spring.core.di;

public class Customer {
    private int id;
    private String name;
    //has-a
    private Address address;

    public Customer() {
    }

    public Customer(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}



package com.ibm.spring.core.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SetterInjection {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-di.xml");
        //Get the customer Bean
        Customer customer = context.getBean(Customer.class);
        //Get all Customer information
        System.out.println("Id" + customer.getId());
        System.out.println("Name " + customer.getName());
        System.out.println("Address " + customer.getAddress().getCity() + " " + customer.getAddress().getState());

        customer.setId(1);
        customer.setName("Subramanian Murugan");
        Address address = customer.getAddress();
        address.setCity("Coimbatore");
        address.setState("Tamil nadu");
        customer.setAddress(address);

        System.out.println("Id" + customer.getId());
        System.out.println("Name " + customer.getName());
        System.out.println("Address " + customer.getAddress().getCity() + " " + customer.getAddress().getState());

    }
}

Constructors Injection:
.......................
beans-di-constructors.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="custAddress" class="com.ibm.spring.core.di.Address">
        <constructor-arg name="city" value="Chennai"/>
        <constructor-arg name="state" value="Tamil Nadu"/>
    </bean>
    <bean id="customer" class="com.ibm.spring.core.di.Customer">
        <constructor-arg name="id" value="1"/>
        <constructor-arg name="name" value="Subramanian Murugan"/>
        <constructor-arg name="address" ref="custAddress"/>
    </bean>

</beans>

package com.ibm.spring.core.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ConstructorInjection {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-di-constructors.xml");
        //Get the customer Bean
        Customer customer = context.getBean(Customer.class);
        //Get all Customer information
        System.out.println("Id" + customer.getId());
        System.out.println("Name " + customer.getName());
        System.out.println("Address " + customer.getAddress().getCity() + " " + customer.getAddress().getState());


    }
}
.....................................................................................
				Dependency Injection values

1.You can inject primitives values- int,float,string,char,boolean
2.You can inject objects -Customer ,Address
3.You can inject list - Collections,Map,List,Set
.....................................................................................	

Assigment -1:

Create Order and Product classes , populate data accordingly using setter and constructor injection...
.....................................................................................
    	   Interface Based Dependency Injection
..................................................................................

1.Declare interface

package com.ibm.spring.core.di.interfaces;

import java.util.List;

public interface Repository {
    List<String> listAll();
}

2.Implementations

package com.ibm.spring.core.di.interfaces;

import java.util.List;

public class SQLRepositoryImpl implements Repository {
    @Override
    public List<String> listAll() {
        return List.of("CREATE", "UPDATE", "DELETE", "SELECT");
    }
}

package com.ibm.spring.core.di.interfaces;

import java.util.List;

public class NOSQLRepositoryImpl implements Repository {
    @Override
    public List<String> listAll() {
        return List.of("SET", "GET");
    }
}

Injector class:
package com.ibm.spring.core.di.interfaces;

public class CustomerDAO {
    private Repository repository;

    public CustomerDAO() {
    }

    public CustomerDAO(Repository repository) {
        this.repository = repository;
    }

    public Repository getRepository() {
        return repository;
    }

    public void setRepository(Repository repository) {
        this.repository = repository;
    }
}


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--     Create all Interface implementations-->

    <bean id="sql" class="com.ibm.spring.core.di.interfaces.SQLRepositoryImpl"/>
    <bean id="nosql" class="com.ibm.spring.core.di.interfaces.NOSQLRepositoryImpl"/>

    <bean id="customerDAO" class="com.ibm.spring.core.di.interfaces.CustomerDAO">
        <!--        <constructor-arg name="repository" ref="nosql"/>-->
        <constructor-arg name="repository" ref="sql"/>
    </bean>


</beans>
Main:
package com.ibm.spring.core.di.interfaces;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class InterfaceMain {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-interface-di.xml");
        CustomerDAO customerDAO = context.getBean(CustomerDAO.class);
        System.out.println(customerDAO.getRepository().listAll());

    }
}
....................................................................................
Bean Definitions:

1.How to create bean 
   class,factory-method

2.How to name beans?
   id,name,alias

3.scope of the beans? : visibility of the bean
   singleton,prototype,
   request,session,application,websocket

4.Dependence Injections
   constructor
   setter
   autowire

5.Lazy initialization mode
 controlling bean creations
  eagar-default
  lazy-ondemand
  lazy-init="true"

5.How to simplify bean injections? 
   Autowiring mode 
 no,byName,byType,constructor  

.....................................................................................
.............................................................................................
					Bean Creation
............................................................................................

1.Via class  
   Spring creates using new Operator
  new Order()
  <bean id="order" class="com.ibm.spring.core.Order"/>

2.Via Factory Pattern

-if constructor marked private
   via factory factory api.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--    <bean id="user" class="com.ibm.spring.core.beans.factory.User">-->
    <!--        <property name="name" value="admin"/>-->
    <!--        <property name="password" value="admin"/>-->
    <!--    </bean>-->

    <!-- Create Instance using factory pattern-->
    <bean id="user" class="com.ibm.spring.core.beans.factory.User" factory-method="getInstance">
        <property name="name" value="admin"/>
        <property name="password" value="admin"/>
    </bean>
</beans>

package com.ibm.spring.core.beans.factory;

public class User {
    private String name;
    private String password;

    private User() {

    }

    public String getName() {
        return name;
    }

    //Factory Method
    public static User getInstance() {
        System.out.println("Factory");
        return new User();
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
package com.ibm.spring.core.beans.factory;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class FactoryMain {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-factory.xml");
        User user = context.getBean(User.class);
        System.out.println(user.getName() + user.getPassword());
    }
}
.....................................................................................
			 Bean Scopes
.....................................................................................
Generally, you can create multiple instance from bean definition.
  some times if you want to control that bean creation
you can use bean creation scope.

Spring supports 6 scopes:
 singleton,prototype - core scope
   request,session,application,websocket -web env


1.singleton
 (Default) Scopes a single bean definition to a single object instance for each Spring IoC container.
 if you call getBean no of time, spring returns the only one instance at any point of time.
This is default scope.


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="hello" class="com.ibm.spring.core.beans.scope.Hello"/>

</beans>
package com.ibm.spring.core.beans.scope;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SingleTon {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-scope.xml");
        Hello hello1 = context.getBean(Hello.class);
        System.out.println(hello1.hashCode());

        Hello hello2 = context.getBean(Hello.class);
        System.out.println(hello2.hashCode());
    }
}

outPut:
1436664465
1436664465

Here we can see the same hashcode value, meaning that , we have only one instance
....................................................................................
2.prototype:
a new bean instance is created every time a request for that specific bean is made 
that is, the bean is injected into another bean or you request it through a getBean() method call on the container.


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="helloProto" class="com.ibm.spring.core.beans.scope.Hello" scope="prototype"/>

</beans>

package com.ibm.spring.core.beans.scope;


import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Prototype {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-scope.xml");
        Hello hello1 = context.getBean(Hello.class);
        System.out.println(hello1.hashCode());

        Hello hello2 = context.getBean(Hello.class);
        System.out.println(hello2.hashCode());
    }
}
Output:
1173643169
1282287470
.....................................................................................
			     Automations

How to gradually reduce configurations from the xml, so that spring takes care internally, we can reduce developer job with related to focusing on configuration...

DI automations:

Dependency Injections:
 ->property - setter injections
 ->constructor-arg ref ->constructor injections

->autowire 
Which is not new injection type, but it simplifies property and constructor injections

     no ->Explicit via property or constructor-arg
     byName - Implicit via property
     byType - Implicit via type + property
     constructor - Implicit via constructor

autowire="no | byName | byType | constructor"

Lab
 
Customer
 |
 Address -- via autowire

Without auto wire:

<!--    Without auto wire - manual injection-->
    <bean id="custAddress" class="com.ibm.spring.core.di.Address">
        <property name="city" value="City"/>
        <property name="state" value="State"/>
    </bean>
    <bean id="customer" class="com.ibm.spring.core.di.Customer">
        <property name="id" value="0"/>
        <property name="name" value="Name"/>
        <!--        Dependency Injection-->
        <property name="address" ref="custAddress"/>
    </bean>


With Auto Wire:

    <bean id="custAddress" class="com.ibm.spring.core.di.Address">
        <property name="city" value="City"/>
        <property name="state" value="State"/>
    </bean>
    <bean id="customer" class="com.ibm.spring.core.di.Customer" autowire="byType">
    </bean>

package com.ibm.spring.core.di.autowrires;

import com.ibm.spring.core.di.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AutoWireInjection {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-autowire.xml");
        Customer customer = context.getBean(Customer.class);
        System.out.println(customer);

    }
}
.....................................................................................
Bean life cycles:
.................

init
destroy

Points:
1.if you want to initalize the resources,
 Resources:
   Resource is nothing but ,something outside jvm
    ex: FileSystem,Databases,Network sockets,Graphics context....
  Resources must be mananaged properly , if not , it will give you
 memory leaks.

In general , resources are initialized inside Class constructors
eg:Establishing database,socket connections, create file points,open file

According to spring best practices, dont do it inside constructor
 Why
   WHich hindrences the bean intialization, which will drop app startup performance.

then where can i initlaize
 spring provides life cycle hooks

   ->init-method="initmethod"
   ->destroy-method="destroymethod" - Resources clean up

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="database" class="com.ibm.spring.core.beans.lifecycles.DatabaseConnection" destroy-method="destroy" init-method="init"/>

</beans>
package com.ibm.spring.core.beans.lifecycles;

public class DatabaseConnection {

    public void init() {
        System.out.println("Database is being initialized");
    }

    public void destroy() {
        System.out.println("Database connection is closed");
    }

}
package com.ibm.spring.core.beans.lifecycles;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class LifeCycles {
    public static void main(String[] args) {
//        ApplicationContext context = new ClassPathXmlApplicationContext("beans-lifecycle.xml");
//        context.getBean(DatabaseConnection.class);

        ConfigurableApplicationContext context = new ClassPathXmlApplicationContext("beans-lifecycle.xml");
        context.getBean(DatabaseConnection.class);

        context.registerShutdownHook();
    }
}
.....................................................................................
.....................................................................................
			 Container Extensions Points
.....................................................................................

Typically, an application developer does not need to subclass  ApplicationContext implementation classes.

 Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. 


Spring core System:

		  Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|
		| Spring IOC Container  |
		------------------------
			|
		       JVM


How to add extensions(plugins) on to the Existing Spring Container?


 		 Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|--->Extensions
					|    1.BeanPostProcessor 
		|			|     etc...
		|			|
		| 			|
		| Spring IOC Container  |
		|			|
		|			|	
		|			|
		|		        |
		------------------------
			|
		       JVM

1.BeanPostProcessor 

1.How to instrument beans
2.How to instrument containers


BeanPostProcessor: Extensions
..................
  BeanPostProcessor are classes that tells Spring what should be done after beans are created.


package com.ibm.spring.core.beans.extensions;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class BeanPostProcessorExtension implements BeanPostProcessor {
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization" + beanName);
        return bean;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization" + beanName);
        return bean;
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="postprocessor" class="com.ibm.spring.core.beans.extensions.BeanPostProcessorExtension"/>
    <bean id="hello" class="com.ibm.spring.core.beans.extensions.Hello"/>


</beans>

package com.ibm.spring.core.beans.extensions;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BeanExtension {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-extensions.xml");
        Hello hello = context.getBean(Hello.class);

    }
}
.....................................................................................
         	     More Container Features(extensions)
.....................................................................................

               Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|--->Extensions
					|    1.BeanPostProcessor 
		|			|    2.Features2
		|			|    3.Feature3
		| 			|    4.FeatureN
		| Spring IOC Container  |
		|			|
		|			|	
		|			|
		|		        |
		------------------------
			|
		       JVM

Spring provides lot of built in extensions.

PropertyPlaceholderConfigurer :
   It is used to externalize the bean property values
eg:

Bean definition file:
  <bean id="customer" class="com.ibm.spring.core.di.Customer">
        <property name="id" value="0"/>
       
  </bean>

Property value is hardcoded, if wan to isloate into some other place.

with PropertyPlaceHolder = ${propertyKey} =>PropertyValue
  <bean id="customer" class="com.ibm.spring.core.di.Customer">
        <property name="id" value="${customer.id}"/>
     
  </bean>

PropertyPlaceholderConfigurer

classpath: resources/application.properties

customer.id=1
customer.name=Subramanian Murugan

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--    In order to read property file-->
    <!--    PropertyPlaceholder extension-->
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations" value="classpath:application.properties"/>
    </bean>
    <bean id="customer" class="com.ibm.spring.core.beans.extensions.Customer">
        <property name="id" value="${customer.id}"/>
        <property name="name" value="${customer.name}"/>
    </bean>
</beans>

How to read Property Values:

package com.ibm.spring.core.beans.extensions;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class PropertyPlaceHolder {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml-extensions.config.xml");
        Customer customer = context.getBean(Customer.class);
        System.out.println(customer.getId() + " " + customer.getName());
    }
}

.....................................................................................
....................................................................................
	  How to introduce Annotations -Annotation Driven configuration
.....................................................................................
Annotations:
 Meta Information about class,methods,fields.

Why Annotation?
 Annotations help to inject "boiler plate code" -The code which is not neccessary for the dev but necessary for compiler,build tools,document generation tools,runtime.

Spring Introduced Annoations to simplify the lot of code generations.

Types of Spring Annotations

1.Spring Properity annotations
2.JSR 250 Annotations 


How to introduce Annotations inside Spring?
 
 Via ContainerExtension Mechanism

Common Annotations:
1.RequiredAnnotationBeanPostProcessor - @Required
2.AutowiredAnnotationBeanPostProcessor  -@Autowrited
3.CommonAnnotationBeanPostProcessor  -@Common
4.PersistenceAnnotationBeanPostProcessor -@Entity
etc....

Steps to integrate Annotations:

1.Activate The Annoation via ContainerExtension Point Beans

beans.xml

 <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/>
 -@Required

 -@Autowried
<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>

What if any one of the AnnotationBeanPostProcessor has its own dependency, we need to inject That as well, other wise it will throw error.


what if i want to use more annotations, i need to add more AnnotationBeanPostProcessor beans in bean.xml
  This is very complex

Note: modern spring has implicitly added annoation post bean processors , so you dont need to add "Core Annotation BeanPostProcessor in beans.xml".
		.....................................................................................
			Automation - Annoation Scanner
.....................................................................................

Spring added feature called automated scanner, which scans all annoations from the build path/class path, creates all the beans related to annotationBeanPostProcessor


How to tell spring container to scan annotations?

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--    Tell to spring to scan all annotations : you dont need to configure annotation post processors-->
    <context:annotation-config/>

</beans>

Autowire Annotation:
....................

package com.ibm.spring.core.annotations;

import org.springframework.beans.factory.annotation.Autowired;

public class Customer {
    private int id;
    private String name;
    @Autowired
    private Address address;

    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    public Customer() {
    }

    public Customer(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.ibm.spring.core.annotations;

public class Address {
    private String city;
    private String state;

    public Address() {
    }

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                ", state='" + state + '\'' +
                '}';
    }

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--    Tell to spring to scan all annotations : you dont need to configure annotation post processors-->
    <context:annotation-config/>
    <bean id="address" class="com.ibm.spring.core.annotations.Address">
        <constructor-arg name="city" value="Coimbatore"/>
        <constructor-arg name="state" value="TamilNadu"/>
    </bean>
    <bean id="customer" class="com.ibm.spring.core.annotations.Customer">
        <constructor-arg name="id" value="100"/>
        <constructor-arg name="name" value="Subramanian"/>
    </bean>
</beans>

package com.ibm.spring.core.annotations;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AutoWiredAnnotation {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-annotation-scanner.xml");
        Customer customer = context.getBean(Customer.class);
        System.out.println(customer);
    }
}
.....................................................................................
....................................................................................
				Bean Life Cycles and annoatations

in order to add life cycle annotations which is not part of spring core which is part of jsr 250. we need to add separate depedency.

in pom.xml
  <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
   </dependency>

package com.ibm.spring.core.annotations;

import org.springframework.beans.factory.annotation.Autowired;

import javax.annotation.PostConstruct;

public class Customer {
    private int id;
    private String name;
    @Autowired
    private Address address;

    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @PostConstruct
    public void init() {
        System.out.println("Init.....");
    }

    @Override
    public String toString() {
        return "Customer{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    public Customer() {
    }

    public Customer(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
....................................................................................
.....................................................................................
			How to reduce code slowly via annotations
.....................................................................................
Types of Annotations
.....................................................................................

1.JSR 250 annoations

@PostConstruct
@PreDestroy

2.Spring Annoations
@Required,@Autowired......etc...

You have beans.xml with annotation configuration, but still we have bean creation definitions how to remove those areas.

How to remove bean definitions from the beans.xml file

   <bean id="customer" class="com.ibm.spring.app.annotations.Customer">
            <property name="id" value="1"/>
            <property name="name" value="Subramanian"/>
   </bean>

Stereotype Annotations:

Stereotype: "Same type of things but it adds extra behaviour based on context"

@Component

What is Component?

The term coined by Microsoft in 1989.
In Object Oriented System Every thing is Object
The Term object is more general term.

Component is also Object(Bean) in spring context
  ->It is resulable
  ->follows all java bean standards

In java technology:
Bean
 In java Bean is called "java Object Only"

EJB
 It is also java object, which is distributed

Enitity
 It is also java object, which is persitable into fs,networks,rdbms

What is use of @Component?
 ->To eleminate bean definition from beans.xml file

<bean id="customerService"  class="com.ae.spring.service.impl.CustomerServiceImpl"/>


Api doc:

 @Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Indexed
public @interface Component

@Component is class level annotation,declared on the top of class.

Indicates that an annotated class is a "component"
Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--    Tell to spring to scan all annation : you dont need to annotation post processors-->
    <context:annotation-config/>

    <bean id="orderService" class="com.ibm.spring.beans.OrderService"/>
</beans>

Auto-detection and component scanning:
base package: com.ae.spring

			    com
			     |
			    ae
			     |
                           spring
		    -----------------------------
		   |                            |
                service                        repo
		   |                            |
		 impl                          impl
-------------------------------       -----------------------------
  |               |                   |                          |
CustomerService ProductService     CustomerRepoImpl          ProductRepoImpl
Impl            Impl

@Component      @Component         @Component                @Component

....................................................................................
			Automation - Stereotype Annoation Scanner   ..............................................................................................
Types of SteroTypes:
1.Component  -@Component
2.Service    -@Service
3.Repository -@Repository
4.Controller -@Controller
5.RestController -@RestController
			  
How to scan SteroTypes?

 <context:component-scan base-package="com.valtech.spring.beans.automation"/>

This package and its subpackages , scan and creates beans and make it ready.

@Component is a generic stereotype for any Spring-managed component.

@Repository, @Service, and @Controller are specializations of @Component for more specific use cases.

by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--    Activate all annotations-->
    <context:annotation-config/>
    <!--Enable StroType annotations and create beans accordingly-->
    <context:component-scan base-package="com.ibm.spring.core"/>
</beans>

package com.ibm.spring.core.annotations.streotypes;

import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class OrderService {

    public List<String> findAll() {
        return List.of("order1", "Order2");
    }
}
package com.ibm.spring.core.annotations.streotypes;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.annotation.Order;

public class ComponentAnnotation {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-annotations-stereo.xml");
        OrderService orderService = context.getBean(OrderService.class);
        System.out.println(orderService.findAll());
    }
}
....................................................................................
			Dependency Injection and SteroTypes
.....................................................................................

package com.ibm.spring.core.annotations.streotypes;

import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class ProductService {

    public List<String> findAllProducts(){
        return  List.of("Product1","Product2","Product3");
    }
}
package com.ibm.spring.core.annotations.streotypes;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class OrderService {

    //Field Injection: No setter and Getter is necessary
    @Autowired
    private ProductService productService;

    public List<String> findAll() {
        return List.of("order1", "Order2");
    }

    public List<String> getProducts() {
        return productService.findAllProducts();
    }
}

package com.ibm.spring.core.annotations.streotypes;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.annotation.Order;

public class ComponentAnnotation {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans-annotations-stereo.xml");
        OrderService orderService = context.getBean(OrderService.class);
        System.out.println(orderService.findAll());
        System.out.println(orderService.getProducts());
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--    Activate all annotations-->
    <context:annotation-config/>
    <!--Enable StroType annotations and create beans accordingly-->
    <context:component-scan base-package="com.ibm.spring.core"/>
</beans>

.....................................................................................				DOMAIN Driven Design
.....................................................................................
 
@Service:

@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Service

Indicates that an annotated class is a "Service", originally defined by Domain-Driven Design (Evans, 2003) as "an operation offered as an interface that stands alone in the model, with no encapsulated state."


@Repository:
@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Repository

indicates that an annotated class is a "Repository", originally defined by Domain-Driven Design (Evans, 2003) as "a mechanism for encapsulating storage, retrieval, and search behavior which emulates a collection of objects".

...........................................................................................

@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Controller
Indicates that an annotated class is a "Controller" (e.g. a web controller).
.....................................................................................
.....................................................................................
			 End of Xml Configuration
.....................................................................................
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--scanner for common Annotation -->
    <context:annotation-config/>
    <!--    Scanner for StreoType Annotations-->
    <context:component-scan base-package="com.valtech.spring.beans.automation"/>
</beans>
....................................................................................
....................................................................................
..............................................................................................
		What if i want to remove this beans.xml itself
			    Java Config
.....................................................................................

What is Java Config?

JavaConfig <=======> beans.xml
  but it is pure java Program.

Why Java config?
  Java Config was introduced to remove XML,

The XML is outside spring.
Spring need to parse xml file and construct objects accordingly
Which is heavy weight.
Spring introduced new configuration system which is written in java itself.
.....................................................................................


Java Configuration:

1.Bean declaration : @Component/@Service/@Repository/@Controller

package com.ibm.spring.core.javaconfig;

import org.springframework.stereotype.Component;

@Component
public class Hello {
    public String sayHello() {
        return "Hello";
    }
}

2.Configuration 
  In old we wrote beans.xml
  Now we dont need beans.xml

Java Configuration:
package com.ibm.spring.core.javaconfig;

package com.ibm.spring.core.javaconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration  //beans
public class AppConfig {

    //<bean id="hello" class="com.ibm.spring.core.javaconfig.Hello"/>
    @Bean
    public Hello createHello() {
        return new Hello();
    }

}

Main: AnnotationConfigApplicationContext(AppConfig.class);

package com.ibm.spring.core.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaConfigMain {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Hello hello = context.getBean(Hello.class);
        System.out.println(hello.sayHello());
    }
}
.....................................................................................
			 Dependency Injection
.....................................................................................
package com.ibm.spring.core.javaconfig;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class OrderService {

    @Autowired
    private CustomerService customerService;

    public String getCustomer() {
        return customerService.getCustomer();
    }
}
package com.ibm.spring.core.javaconfig;

import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    public String getCustomer() {
        return "Customer!!!";
    }
}
package com.ibm.spring.core.javaconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration  //beans
public class AppConfig {

    //<bean id="hello" class="com.ibm.spring.core.javaconfig.Hello"/>
    @Bean
    public Hello createHello() {
        return new Hello();
    }

    @Bean
    public CustomerService createCustomer() {
        return new CustomerService();
    }

    @Bean
    public OrderService createOrderService() {
        return new OrderService();
    }
}
package com.ibm.spring.core.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaConfigDependencyInjection {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        OrderService orderService = context.getBean(OrderService.class);
        System.out.println(orderService.getCustomer());
    }
}
.....................................................................................
			Modularity and configuration

Instead of creating/mapping beans in one single place "AppConfig" going to be complex, we can break configurations into multiple configs, then latter we can combine into single config.


modular definition files

1.XML is so complex to maintain when app grows.
   -In general we can have multiple configurations
  like
	projectname-dao.xml
	cleartrip.dao.xml 
        cleartrip.service.xml
        cleartrip.entitis.xml
	cleartrip.beans.xml
via Program:
ConfigurableApplicationContext context = ClassPathXmlApplicationContext("bank-app.xml","account-repo.xml");

or
ConfigurableApplicationContext context = new ClassPathXmlApplicationContext
new String[] { "bank-app.xml", "account-repo.xml" });

How to break the configuration in annotations?

customer
 @Configuration
 class  CustomerConfig {
   ///customer beans
 }

order
@Configuration
 class  OrderConfig {
   ///customer beans
 }
accounts
@Configuration
 class  AccountsConfig {
   ///customer beans
 }
............

Eg:
package com.ibm.spring.core.javaconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class HelloConfig {

    @Bean
    public  Hello createHello(){
        return  new Hello();
    }
}

package com.ibm.spring.core.javaconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomerConfig {
    @Bean
    public  CustomerService createCustomerService(){
        return  new CustomerService();
    }
}

package com.ibm.spring.core.javaconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OrderConfig {

    @Bean
    public OrderService createOrderService() {
        return new OrderService();
    }
}
package com.ibm.spring.core.javaconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration  //beans
@Import({HelloConfig.class, CustomerConfig.class, OrderConfig.class})
public class AppConfig {}

package com.ibm.spring.core.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaConfigDependencyInjection {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        OrderService orderService = context.getBean(OrderService.class);
        System.out.println(orderService.getCustomer());
    }
}
.....................................................................................
		How to remove bean creations from the java config
....................................................................................
@Component-scan === beans.xml <context:component-scan base-package="com.ibm.spring">

Note:
 Please disable all any code which is written to create beans automatically.
Note:
 create new Project 


package com.ibm.spring.core;

import org.springframework.stereotype.Service;

@Service
public class HelloService {

    public String sayHello() {
        return "Hello";
    }
}
package com.ibm.spring.core;

public class User {
    private String id;
    private String name;

    public User() {
    }

    public User(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}


package com.ibm.spring.core;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;

@ComponentScan(basePackages = "com.ibm")
public class AppConfig {

    //Bean
    @Bean
    public User createUser(){
        return  new User();
    }
}

package com.ibm.spring.core;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaConfigMain {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        HelloService helloService = context.getBean(HelloService.class);
        System.out.println(helloService.sayHello());
        User user = context.getBean(User.class);
        System.out.println(user);
    }
}
....................................................................................
		    Auto Configuration : Automation 
.....................................................................................
Spring allows us automatically configure your spring application based on bean definitions in the "class path"

How to opt-in auto configuration?

@EnableAutoConfiguration or @SpringBootApplication.
.....................................................................................
			 Getting started with Spring Boot Architecture
....................................................................................

What is Spring Boot?

  Spring Boot is configuration system, this configure beans auotmatically without using any explicit/external configurations defined by developer.

 auto-configuration attempts to automatically configure your Spring application based on the "jar dependencies" that you have added

 Spring Boot is going to initalize the beans , not only in the application but also in the jar files.

 You are going to create spring application, which uses the following features

 1.web 
 2.database
 3.logging
 4.caching

for ex, i want to connect to database called mysql, i need to configure datasources,connection informations,transactions, hibernate and jpa configurations...
In the bean defintions..
  But in Spring 5.x autoconfiguration helps to configure spring app in easy way based on "opinions" such i want database,i want to build webservice, i want to enable logging, i want to enable caching, i want to enable SomeXXX...

if i want, add that jar in the class, spring prvoides most of the common settings to kick start app as quick as possible.

 Spring team, created a separate project based on "auto configuration" , that is called "Spring Boot".


Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".

We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.

Spring Boot Focus Mainly Configuration

1.Build Configuration - lib configuration -pom.xml
2.Application Configuration.

					Why Spring Boot?

Spring Boot  starters reduces build dependency - POM Dependencies/project dependencies  AutoConfigrator reduces the AppDepedency

1.Create stand-alone Spring applications
   You can deploy apps in containers,cloud.....easily

2.Embeded Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
   SPring boots provides execuatble jar / fat jar /uber jar.	

3.Provide opinionated 'starter' dependencies to simplify your build configuration
     Looks like profie based configuration which is applied even for pom dependencies

4.Automatically configure Spring and 3rd party libraries whenever possible
    Via autoconfiguration and class path scanning.

Provide production-ready features such as metrics, health checks, and externalized configuration

How to begin with spring boot application?

YOu can create standalone spring boot app 
YOu can create web spring boot app


if you want to create spring boot project, https://start.spring.io/


Use Case : How to create standalone cli based Spring boot application.

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.3</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.ibm</groupId>
	<artifactId>springbootbasics</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>springbootbasics</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>


package com.ibm.springbootbasics;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootbasicsApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootbasicsApplication.class, args);
	}

}

After Running;
"C:\Program Files\Java\jdk-17\bin\java.exe" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.3.4\lib\idea_rt.jar=61026:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.3.4\bin" -Dfile.encoding=UTF-8 -classpath G:\IBM\2024\March\SpringMicroservices\springbootbasics\target\classes;C:\Users\subu\.m2\repository\org\springframework\boot\spring-boot-starter\3.2.3\spring-boot-starter-3.2.3.jar;C:\Users\subu\.m2\repository\org\springframework\boot\spring-boot\3.2.3\spring-boot-3.2.3.jar;C:\Users\subu\.m2\repository\org\springframework\spring-context\6.1.4\spring-context-6.1.4.jar;C:\Users\subu\.m2\repository\org\springframework\spring-aop\6.1.4\spring-aop-6.1.4.jar;C:\Users\subu\.m2\repository\org\springframework\spring-beans\6.1.4\spring-beans-6.1.4.jar;C:\Users\subu\.m2\repository\org\springframework\spring-expression\6.1.4\spring-expression-6.1.4.jar;C:\Users\subu\.m2\repository\io\micrometer\micrometer-observation\1.12.3\micrometer-observation-1.12.3.jar;C:\Users\subu\.m2\repository\io\micrometer\micrometer-commons\1.12.3\micrometer-commons-1.12.3.jar;C:\Users\subu\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\3.2.3\spring-boot-autoconfigure-3.2.3.jar;C:\Users\subu\.m2\repository\org\springframework\boot\spring-boot-starter-logging\3.2.3\spring-boot-starter-logging-3.2.3.jar;C:\Users\subu\.m2\repository\ch\qos\logback\logback-classic\1.4.14\logback-classic-1.4.14.jar;C:\Users\subu\.m2\repository\ch\qos\logback\logback-core\1.4.14\logback-core-1.4.14.jar;C:\Users\subu\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.21.1\log4j-to-slf4j-2.21.1.jar;C:\Users\subu\.m2\repository\org\apache\logging\log4j\log4j-api\2.21.1\log4j-api-2.21.1.jar;C:\Users\subu\.m2\repository\org\slf4j\jul-to-slf4j\2.0.12\jul-to-slf4j-2.0.12.jar;C:\Users\subu\.m2\repository\jakarta\annotation\jakarta.annotation-api\2.1.1\jakarta.annotation-api-2.1.1.jar;C:\Users\subu\.m2\repository\org\springframework\spring-core\6.1.4\spring-core-6.1.4.jar;C:\Users\subu\.m2\repository\org\springframework\spring-jcl\6.1.4\spring-jcl-6.1.4.jar;C:\Users\subu\.m2\repository\org\yaml\snakeyaml\2.2\snakeyaml-2.2.jar;C:\Users\subu\.m2\repository\org\slf4j\slf4j-api\2.0.12\slf4j-api-2.0.12.jar com.ibm.springbootbasics.SpringbootbasicsApplication

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.3)

2024-03-21T10:50:14.455+05:30  INFO 7756 --- [springbootbasics] [           main] c.i.s.SpringbootbasicsApplication        : Starting SpringbootbasicsApplication using Java 17.0.10 with PID 7756 (G:\IBM\2024\March\SpringMicroservices\springbootbasics\target\classes started by subu in G:\IBM\2024\March\SpringMicroservices\springbootbasics)
2024-03-21T10:50:14.457+05:30  INFO 7756 --- [springbootbasics] [           main] c.i.s.SpringbootbasicsApplication        : No active profile set, falling back to 1 default profile: "default"
2024-03-21T10:50:15.159+05:30  INFO 7756 --- [springbootbasics] [           main] c.i.s.SpringbootbasicsApplication        : Started SpringbootbasicsApplication in 1.131 seconds (process running for 1.495)

Process finished with exit code 0

.....................................................................................
			Spring Boot Maven Dependency Graph
....................................................................................
[INFO] com.ibm:springbootbasics:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.boot:spring-boot-starter:jar:3.2.3:compile
[INFO] |  +- org.springframework.boot:spring-boot:jar:3.2.3:compile
[INFO] |  |  \- org.springframework:spring-context:jar:6.1.4:compile
[INFO] |  |     +- org.springframework:spring-aop:jar:6.1.4:compile
[INFO] |  |     +- org.springframework:spring-beans:jar:6.1.4:compile
[INFO] |  |     +- org.springframework:spring-expression:jar:6.1.4:compile
[INFO] |  |     \- io.micrometer:micrometer-observation:jar:1.12.3:compile
[INFO] |  |        \- io.micrometer:micrometer-commons:jar:1.12.3:compile
[INFO] |  +- org.springframework.boot:spring-boot-autoconfigure:jar:3.2.3:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-logging:jar:3.2.3:compile
[INFO] |  |  +- ch.qos.logback:logback-classic:jar:1.4.14:compile
[INFO] |  |  |  \- ch.qos.logback:logback-core:jar:1.4.14:compile
[INFO] |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.21.1:compile
[INFO] |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.21.1:compile
[INFO] |  |  \- org.slf4j:jul-to-slf4j:jar:2.0.12:compile
[INFO] |  +- jakarta.annotation:jakarta.annotation-api:jar:2.1.1:compile
[INFO] |  +- org.springframework:spring-core:jar:6.1.4:compile
[INFO] |  |  \- org.springframework:spring-jcl:jar:6.1.4:compile
[INFO] |  \- org.yaml:snakeyaml:jar:2.2:compile
[INFO] \- org.springframework.boot:spring-boot-starter-test:jar:3.2.3:test
[INFO]    +- org.springframework.boot:spring-boot-test:jar:3.2.3:test
[INFO]    +- org.springframework.boot:spring-boot-test-autoconfigure:jar:3.2.3:test
[INFO]    +- com.jayway.jsonpath:json-path:jar:2.9.0:test
[INFO]    |  \- org.slf4j:slf4j-api:jar:2.0.12:compile
[INFO]    +- jakarta.xml.bind:jakarta.xml.bind-api:jar:4.0.1:test
[INFO]    |  \- jakarta.activation:jakarta.activation-api:jar:2.1.2:test
[INFO]    +- net.minidev:json-smart:jar:2.5.0:test
[INFO]    |  \- net.minidev:accessors-smart:jar:2.5.0:test
[INFO]    |     \- org.ow2.asm:asm:jar:9.3:test
[INFO]    +- org.assertj:assertj-core:jar:3.24.2:test
[INFO]    |  \- net.bytebuddy:byte-buddy:jar:1.14.12:test
[INFO]    +- org.awaitility:awaitility:jar:4.2.0:test
[INFO]    +- org.hamcrest:hamcrest:jar:2.2:test
[INFO]    +- org.junit.jupiter:junit-jupiter:jar:5.10.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-api:jar:5.10.2:test
[INFO]    |  |  +- org.opentest4j:opentest4j:jar:1.3.0:test
[INFO]    |  |  +- org.junit.platform:junit-platform-commons:jar:1.10.2:test
[INFO]    |  |  \- org.apiguardian:apiguardian-api:jar:1.1.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-params:jar:5.10.2:test
[INFO]    |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.10.2:test
[INFO]    |     \- org.junit.platform:junit-platform-engine:jar:1.10.2:test
[INFO]    +- org.mockito:mockito-core:jar:5.7.0:test
[INFO]    |  +- net.bytebuddy:byte-buddy-agent:jar:1.14.12:test
[INFO]    |  \- org.objenesis:objenesis:jar:3.3:test
[INFO]    +- org.mockito:mockito-junit-jupiter:jar:5.7.0:test
[INFO]    +- org.skyscreamer:jsonassert:jar:1.5.1:test
[INFO]    |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test
[INFO]    +- org.springframework:spring-test:jar:6.1.4:test
[INFO]    \- org.xmlunit:xmlunit-core:jar:2.9.1:test
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  6.282 s
[INFO] Finished at: 2024-03-21T10:57:57+05:30
[INFO] ------------------------------------------------------------------------

Here one pom dependency will bring all dependant libs.


AutoConfiguration:
..................

Configuration is based on config meta data provied in "META-INF/spring.factories"

org.springframework.boot.spring-autoconfigure.2.5.3

spring.factories 
  It is meta configuration file read by spring container to create objects/beans based on certain conditions -rules


Spring container scans spring.factories file , starts loading configuration, which apples @condtional annotations.

  Container------|AppConfig----|spring.factories----starts initalizing beans/configurations/components   based on rules(conditions) => Spring Boot.


additional-spring-configuration-metadata.json

  {
      "name": "server.port",
      "defaultValue": 8080
    }


Annotations are processed by ASM - java bytecode engineering lib.
https://asm.ow2.io/
.....................................................................................
			  How opinioned app development works
			    (Conditional Bean Creations)
...................................................................................


   When building a spring boot app, we sometimes want to only load beans or modules(configurations) into the application context(container) if some conditions met, Be it disable some beans during tests, or react to a certain property in the runtime env.


eg:

 Some beans work in test env, the same bean i dont want in production env.
 enable or disable some certain cross cutting concerns.
  eg:
    we have built a module that configures security, during dev test, we dont want to have username and passwords every time. so i want to disable the whole security module in local tests.
 
 if some external resources is available without which they cant work. 
   for eg: my application should not work if there is no logback.xml file has been found on classpath.

- if beans does not exits  / exits
- if module does not exits / exits
- if external does not exits  / exits

Declaring Conditional Bean:
..........................
In application, you can declare bean any where, optionaly we can add condition.

only if this condition is satisifed will the bean added to the application context


eg:

@Configuration
class MyBeanConfig {

 @Conditional(...)
 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}

Module Level

@Configuration
@Conditional(...)
class MyBeanConfig {

 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}

Component Level

@Component
@Conditional(...)
class MyComponent {

 
}
........................................................................................................

PreDefined Conditions:
......................
1.ConditionalOnProperty 
   Loads beans based on env property - application.properties
2.ConditionalOnExpression
3.ConditionalOnBean
4.ConditionalOnMissingBean
5.ConditionalOnResource
6.ConditionalOnClass
7.ConditionalOnJava -  version based

etc..
custom conditions
Boolean Operators
Or
And

ConditionalBean:

-OnBean - The bean if  threre , what should i do

eg:
if Mysql dependency (driver jar) in the build path
     -Create Datasource Object
           -Add properties - connection string - url,password,userName


-OnMissing -Then bean if not there ,what should i do
  if web missing, then start console container

Implmentation: Conditional:
............................
package com.ibm.springbootbasics.config;

public class OptionalBean {
    public OptionalBean() {
        System.out.println("Optional Bean");
    }
}
package com.ibm.springbootbasics.config;

public class DependantBean {
    public DependantBean() {
        System.out.println("Dependant Bean is ready!");
    }
}
package com.ibm.springbootbasics.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DependantBeanConfig {

    @Bean
    public OptionalBean optionalBean() {
        return new OptionalBean();
    }

    @Bean
    //@ConditionalOnMissingBean(OptionalBean.class)
    @ConditionalOnBean(OptionalBean.class)
    //create this bean(DependantBean only if  Optional Bean is Avaliable, if not dont create
    public DependantBean dependantBean() {
        return new DependantBean();
    }


}
package com.ibm.springbootbasics;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootbasicsApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootbasicsApplication.class, args);
	}

}
ackage com.valtech.bootapp.conditionalonclass;

public class RequiredClass {
}
package com.valtech.bootapp.conditionalonclass;

import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
//@ConditionalOnClass(name = "com.valtech.bootapp.conditionalonclass.RequiredClass2")
public class SpringConfig {

    @Bean
    //@ConditionalOnClass(value = RequiredClass.class)
//    @ConditionalOnClass(name = "com.valtech.bootapp.conditionalonclass.RequiredClass")
    public MyClass getMyClass() {
        return new MyClass();
    }
    @Bean
    //@ConditionalOnClass(value = RequiredClass.class)
//    @ConditionalOnMissingClass("com.valtech.bootapp.conditionalonclass.RequiredClass1")
    public MyClass getMyClassMissing() {
        return new MyClass("Missing Class");
    }

    public static class MyClass {

        public MyClass(String message) {
            System.out.println(message);
        }

        public MyClass() {
            System.out.println("MyClass");
        }
    }
}


Conditional Componnent:

@Component
@ConditionalXXX
public class MyComponent{}

@ConditionalOnProperty("value.endabled",havingValue="true",matchIfMissing=true)
@Configuration
public class CrossCuttingModule{

}
....................................................................................
				......................................................................................			@SpringBootApplication
.....................................................................................

@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
@SpringBootApplication

ackage com.ibm;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
//@SpringBootConfiguration
//@EnableAutoConfiguration
//@ComponentScan
public class MyspringbootApplication {

	public static void main(String[] args) {
		SpringApplication.run(MyspringbootApplication.class, args);
	}

}
Configuration   ------> Bean Creations - <bean>
@@SpringBootConfiguration

@EnableAutoConfiguration

 -Tells Spring boot to guess how you  want to configure spring,based on the jar dependencies that you have addeded

-IT auto configures the beans that are present in the class path.

 This simplifies the developer work by guuessing the required beans from the class path and configures to run the application.

-for eg, H2 is on your class path, you have not manually configured any database connection beans, then spring will auto configure an in memory database.


@ComponentScan
 Tells spring to look for other components,configurations and all services in the specificied package.
Spring is able to auto scan,detect  and register your beans or components from predefined project package.
if no package is specified current class package is taken as the root package.
.....................................................................................
			  Bean creations in Spring Boot
.....................................................................................

package com.ibm.springbootbasics.beans;

import org.springframework.stereotype.Service;

@Service
public class HelloService {
    public String sayHello() {
        return "Hello";
    }
}
package com.ibm.springbootbasics.beans;

public class User {
    private String id;
    private String name;

    public User(String id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                '}';
    }

    public User() {
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
package com.ibm.springbootbasics.beans.config;

import com.ibm.springbootbasics.beans.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public User createUser() {
        return new User("1", "Subramanian");
    }
}
package com.ibm.springbootbasics;

import com.ibm.springbootbasics.beans.HelloService;
import com.ibm.springbootbasics.beans.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class SpringBootBeanCreations {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(SpringBootBeanCreations.class);
        var hello = context.getBean(HelloService.class);
        System.out.println(hello.sayHello());
        var user = context.getBean(User.class);
        System.out.println(user);
    }
}

Note:

YOu have to have Explicit configuration and bean creation if the class is not annotated with any "StreoType" Annotations.
.....................................................................................
		Command Line Runner Interface
....................................................................................

CommandLineRunner interface is used to initalize the some data during app start up,
which is similar to "Life Cycle Hooks" in Bean...
CommandLineRunner is not part of any bean, rather part of whole app.

Use Cases:

1.Data base mock data initalization

Example:

There are two ways

1.Via interface implementations like tradtional OO style
2.via Functional programming..

package com.ibm.springbootbasics;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CommandLineInterfaceDemo implements CommandLineRunner {
    public static void main(String[] args) {
        var context = SpringApplication.run(CommandLineInterfaceDemo.class);
    }

    @Override
    public void run(String... args) throws Exception {
        System.out.println("something... is being initalized");
    }
}

Functional Style:
package com.ibm.springbootbasics.config;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CommandLineInterfaceFunctionalStyle {
    public static void main(String[] args) throws Exception {
        var context = SpringApplication.run(CommandLineInterfaceFunctionalStyle.class);

//        var r=new CommandLineRunner() {
//            @Override
//            public void run(String... args) throws Exception {
//                System.out.println("something is initalized");
//               System.out.println(args);
//            }
//        };
//        r.run("hello , run");
//        new CommandLineRunner() {
//            @Override
//            public void run(String... args) throws Exception {
//                System.out.println("something is initalized");
//                System.out.println(args);
//            }
//        }.run();
        //r.run("hello , run");
        ((CommandLineRunner) args1 -> {
            System.out.println("something is initalized");
            System.out.println(args1);
        }).run();

    }
}
....................................................................................
			CommandLineRunner in a separate class
....................................................................................

package com.ibm.springbootbasics;

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class DataLoader implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println("Loading data...");

    }
}
package com.ibm.springbootbasics;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CommandLineRunnerSeparate {
    public static void main(String[] args) {
        var context = SpringApplication.run(CommandLineRunnerSeparate.class);
    }
}
.....................................................................................
		Higher order function pattern-Return Function
.....................................................................................
package com.ibm.springbootbasics;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CommandLineInterfaceHOF {
    public static void main(String[] args) {
        var context = SpringApplication.run(CommandLineRunnerSeparate.class);
        try {
            runner().run("");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    //separate method
    public static CommandLineRunner runner() {
//        return new CommandLineRunner() {
//            @Override
//            public void run(String... args) throws Exception {
//                System.out.println("runner is initialized");
//            }
//        };
        //lambda version
        return args -> System.out.println("runner is initialized");
    }
}
.....................................................................................
	 CommandLineRunner interface ,functional Style,automated bean creations
....................................................................................

    public static CommandLineRunner runner() {

        //lambda version
        return args -> System.out.println("runner is initialized");
    }

      public static void main(String[] args) {
        var context = SpringApplication.run(CommandLineRunnerSeparate.class);
        try {
            runner().run("");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

In the above pattern, run method need to be called...

package com.ibm.springbootbasics;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.Bean;

public class CommandLineRunnerBean {
    public static void main(String[] args) {
        var context = SpringApplication.run(CommandLineRunnerBean.class);

    }

    @Bean
    public CommandLineRunner runner() {
        return args -> System.out.println("Bean runner is initialized");
    }
}
.....................................................................................
			How to access application.properties 
....................................................................................
	
In order to define properties, just add properties in application.properties
spring.application.name=springbootbasics

#Custom application properties
greeter.message=Hello
greeter.name=Subramanian Murugan

in order to read property value , we have @Value("${property.name}") annotation.


package com.ibm.springbootbasics.properties;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Greeter {

    @Value("${greeter.message}")
    private String message;

    @Value("${greeter.name}")
    private String name;

    public String getMessage() {
        return message + name;
    }
}
package com.ibm.springbootbasics.properties;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PropertyMain {
    public static void main(String[] args) {
        var context = SpringApplication.run(PropertyMain.class);
        var greeter = context.getBean(Greeter.class);
        System.out.println(greeter.getMessage());

    }
}
.....................................................................................
             Reading Properties via "Environment" Object
....................................................................................

package com.ibm.springbootbasics.properties;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class Greeter {

    @Value("${greeter.message}")
    private String message;

    @Value("${greeter.name}")
    private String name;

    @Autowired
    private Environment environment;

    public String getMessage() {
        return message + name;
    }

    public String getInfo() {
        return environment.getProperty("greeter.message", "Hey");
    }
}
application.properties
spring.application.name=springbootbasics

#Custom application properties
greeter.message=Hello
greeter.name=Subramanian Murugan


@Value vs Environment:
......................

@Value annotation is used to read value from application.properties ,if property does not , it will throw error.

Environment is used to read value from application.properties, if property does not exits, we can provide default value.
....................................................................................
	  Isloating properties into separate class inject Where ever you want
....................................................................................


application.properties
#property category
app.name=MyApp
app.author=Ibm
app.version=1.1.0
app.type=webapp

package com.ibm.springbootbasics.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "app")
public class AppConfiguration {

    private String name;
    private String author;
    private String version;
    private String type;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
}

package com.ibm.springbootbasics.properties;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class Greeter {

    @Value("${greeter.message}")
    private String message;

    @Value("${greeter.name}")
    private String name;

    @Autowired
    private Environment environment;

    //Inject Configuration class
    @Autowired
    private AppConfiguration appConfiguration;

    public String getMessage() {
        return message + name;
    }

    public String getInfo() {
        return environment.getProperty("greeter.message", "Hey");
    }

    public String getConfig() {
        return appConfiguration.getName() + " " + appConfiguration.getAuthor();
    }
}
....................................................................................
			Reading Properties within Property file
.....................................................................................
spring.application.name=springbootbasics

#Custom application properties
greeter.message=Hello
greeter.name=Subramanian Murugan

#property category
app.name=${spring.application.name}
app.author=Ibm
app.version=1.1.0
app.type=webapp

Based on "Spel" Spring Expression language
.....................................................................................
